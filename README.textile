h1. Vault

CoffeeScript/JavaScript online/offline data store.

This library acts as a container for a collection of arbitrary objects, providing persistence using RESTful JSON web services and HTML5 offline storage. It will can a collection, add objects, track changes, and synchronize said changes back to the server. It's ideal for environments where a stable connection can't be guaranteed, and data (as well as modifications) need to be cached and synchronized in batch.

Read-only apps need not specify all URLs; a list-only map will suffice.

h2. Methods

h3. Constructor

<pre>
var my_vault = new Vault(name, urls, id_attribute, [options]);
</pre>

* *name* The name of your dataset. This must be unique across multiple Vault instances, since it's used as a key for offline storage.
* *urls* A dictionary/hash map of up to four URLs used to read/write data from a *JSON* web service:
** *list* GET url for all of the objects in the collection.
** *create* POST url for a new object in the collection.
** *update* POST (I know, should be PUT, but ran into some issues with browser support) url for an existing object in the collection.
** *delete* DELETE url for an existing object in the collection.
* *id_attribute* The unique identifier for this dataset.
* *options* A dictionary/hash map of options for the vault:
** *autoload* _default: true_ Automatically load the dataset upon initialization, favoring offline data if enabled and available in the local storage. If offline load fails, defaults to loading live data.
** *offline* _default: false_ Serializes and stores the collection for offline use whenever the page is unloaded.

h3. fetch(id)

Used to retrieve an object from the collection.

* *id* The id of the object to retrieve. This is based on the _id_attribute_ set in the constructor.

h3. delete(id)

Used to update an object in the collection.

* *id* The id of the object to delete. This is based on the _id_attribute_ set in the constructor.

h3. save(complete_callback)

Iterates over any dirty objects and saves the changes to the server, individually, using the urls configured in the constructor. This method checks if you're online before attempting to do any of this.

* *complete_callback* A function to call once the save operation is complete. This is handy for dismissing loading masks.

h3. reload(complete_callback)

Discards the current collection and reloads it from the server using the _list_ url configured in the constructor. When used alone, this function is handy for purging any changes and starting from scratch.

* *complete_callback* A function to call once the save operation is complete. This is handy for dismissing loading masks.

h3. synchronize(complete_callback)

Convenience function for saving and reloading in a single shot.

* *complete_callback* A function to call once the save operation is complete. This is handy for dismissing loading masks.

h3. load()

Load the collection from the offline data store.

_returns boolean for success/failure_

h3. store()

Store the collection in the offline data store.

h2. Data Format

As previously stated, this library works exclusively with JSON data sources. The expected formats for each URL are as follows:

* *list:* _(GET)_ An array of objects
Expected data:
<pre>
[{object1_attr1: value, object1_attr2: value},{object2_attr1: value, object2_attr2: value}]
</pre>

* *create:* _(POST)_ An object, sent without an id.
POSTed data:
<pre>
{object1_attr1: value, object1_attr2: value}
</pre>

* *update:* _(POST)_ An object.
POSTed data:
<pre>
{object1_attr1: value, object1_attr2: value}
</pre>

* *delete:* _(DELETE)_ An object.
DELETEd data:
<pre>
{object1_attr1: value, object1_attr2: value}
</pre>

h2. Best Practices

Make sure to check your vault's _errors_ array in your _complete_callback_ methods, since this method will be called regardless of whether or not the function succeeded. These errors will be flushed the next time you call the _save_ method.