h1. Vault

CoffeeScript/JavaScript online/offline data store.

This library acts as a container for a collection of arbitrary objects, providing persistence using RESTful JSON web services and HTML5 offline storage. It will can a collection, add objects, track changes, and synchronize said changes back to the server. It's ideal for environments where a stable connection can't be guaranteed, and data (as well as modifications) need to be cached and synchronized in batch.

Read-only apps need not specify all URLs; a list-only map will suffice.

h2. Vault - Public Methods

h3. Constructor

<pre>
var my_vault = new Vault(name, urls, [options]);
</pre>

* *name* The name of your dataset. This must be unique across multiple Vault instances, since it's used as a key for offline storage.
* *urls* A dictionary/hash map of up to four URLs used to read/write data from a *JSON* web service:
** *list* GET url for all of the objects in the collection.
** *create* POST url for a new object in the collection.
** *update* POST (I know, should be PUT, but ran into some issues with browser support) url for an existing object in the collection.
** *delete* DELETE url for an existing object in the collection.
* *options* A dictionary/hash map of options for the vault:
** *autoload* _default: true_ Automatically load the dataset upon initialization, favoring offline data if enabled and available in the local storage. If offline load fails, defaults to loading live data.
** *after_load* _default: null_ Function to call after the autoload process has completed.
** *id_attribute* _default: id_ The unique identifier for this dataset.
** *offline* _default: false_ Serializes and stores the collection for offline use whenever the page is unloaded.

h3. add(object)

Add an object to the collection.

* *object* The new object to be added.

*Note:* If an id hasn't already been assigned to the object, a unique one will be generated and assigned to the new object, and will be superseded by a real id generated server-side after a successful save.

h3. fetch(id)

Used to retrieve an object from the collection.

* *id* The id of the object to retrieve. This is based on the _id_attribute_ set in the constructor.

*Note:* The object returned by this method can by updated and deleted by calling _update()_ and _delete()_, respectively, on the object itself.

h3. update(object)

Update an object in the collection. The object will be matched to its associated object in the collection based on its _id_attribute_.

* *object* Updated object.

*Note:* You can also update an object retrieved using the _fetch()_ method by calling _update()_ on the returned object itself.

h3. delete(id)

Used to update an object in the collection.

* *id* The id of the object to delete. This is based on the _id_attribute_ set in the constructor.

*Note:* All objects in the collection are extended with a _delete_ method which makes it easier to perform this task if you already have a reference to the target object.

h3. save(after_save)

Iterates over any dirty objects and saves the changes to the server, individually, using the urls configured in the constructor. This method checks if you're online before attempting to do any of this.

* *after_save* A function to call once the save operation is complete. This is handy for dismissing loading masks.

h3. reload(after_load)

Discards the current collection and reloads it from the server using the _list_ url configured in the constructor. When used alone, this function is handy for purging any changes and starting from scratch.

* *after_load* A function to call once the save operation is complete. This is handy for dismissing loading masks.

h3. synchronize(after_sync)

Convenience function for saving and reloading in a single shot.

* *after_sync* A function to call once the save operation is complete. This is handy for dismissing loading masks.

h3. load()

Load the collection from the offline data store.

_returns boolean for success/failure_

h3. store()

Store the collection in the offline data store.

h2. Vault - Internal Methods

You shouldn't be accessing these methods directly, but they're documented for development purposes.

h3. extend(object, status)

Extends an object with vault-specific variables and functions.

* *object* The object to which the variables and functions will be applied.
* *status* The status to which the object should be set when extended.

h3. strip(object)

Removes vault-specific variables and functions applied to an object.

* *object* The object to which the variables and functions will be applied.

h2. Data Format

As previously stated, this library works exclusively with JSON data sources. The expected formats for each URL are as follows:

* *list:* _(GET)_ An array of objects
Expected data:
<pre>[{object1_attr1: value, object1_attr2: value},{object2_attr1: value, object2_attr2: value}]</pre>

* *create:* _(POST)_ An object, sent without an id. Expects the same object returned with an id.
POSTed data:
<pre>{object1_attr1: value, object1_attr2: value}</pre>
Expected data:
<pre>{object1_attr1: value, object1_attr2: value}</pre>

* *update:* _(POST)_ An object.
POSTed data:
<pre>{object1_attr1: value, object1_attr2: value}</pre>

* *delete:* _(DELETE)_ An object.
DELETEd data:
<pre>{object1_attr1: value, object1_attr2: value}</pre>

h2. Best Practices

Make sure to check your vault's _errors_ array in your _after_load/save/sync_ methods, since this method will be called regardless of whether or not the function succeeded. These errors will be flushed the next time you call the _save_ method.